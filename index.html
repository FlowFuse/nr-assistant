<script>
    (function (RED, n) {
        'use strict'
        const AI_TIMEOUT = 90000 // default request timeout in milliseconds
        const modulesAllowed = RED.settings.functionExternalModules !== false
        const assistantOptions = {
            enabled: false,
            requestTimeout: AI_TIMEOUT
        }
        let assistantInitialised = false
        console.debug('nr-assistant loading...')
        RED.plugins.registerPlugin('flowfuse-nr-assistant', {
            type: 'assistant',
            name: 'Node-RED Assistant Plugin',
            icon: 'font-awesome/fa-magic',
            onadd: async function () {
                RED.comms.subscribe('nr-assistant/#', (topic, msg) => {
                    debug('comms', topic, msg)
                    if (topic === 'nr-assistant/initialise') {
                        assistantOptions.enabled = !!msg?.enabled
                        assistantOptions.requestTimeout = msg?.requestTimeout || AI_TIMEOUT
                        initAssistant(msg)
                    }
                })
            }
        })

        function initAssistant () {
            if (assistantInitialised) {
                return
            }
            console.debug('nr-assistant initialising...')
            if (!assistantOptions.enabled) {
                console.warn('The FlowFuse Assistant is not enabled')
                return
            }

            if (!window.monaco) {
                console.warn('Monaco editor not found. Unable to register code lens provider. Consider using the Monaco editor for a better experience.')
                return
            } else {
                const commandId = 'nr-assistant-fn-inline'
                monaco.languages.registerCodeLensProvider('javascript', {
                    provideCodeLenses: function (model, token) {
                        const thisEditor = getMonacoEditorForModel(model)
                        if (!thisEditor) {
                            return
                        }
                        const node = RED.view.selection()?.nodes?.[0]

                        // only support function nodes for now
                        if (!node || !node.type === 'function') {
                            return
                        }
                        // Only support the "on message" editor for now
                        // determine which editor is active and if it the "on message" editor
                        // if not, return nothing to prevent the code lens from showing
                        let isFuncTabEditor
                        let el = thisEditor.getDomNode()
                        while (el && el.tagName !== 'FORM') {
                            if (el.id === 'node-input-func-editor' || el.id === 'func-tab-body') {
                                isFuncTabEditor = true
                                break
                            }
                            el = el.parentNode
                        }
                        if (!isFuncTabEditor) {
                            return
                        }

                        return {
                            lenses: [
                                {
                                    range: {
                                        startLineNumber: 1,
                                        startColumn: 1,
                                        endLineNumber: 2,
                                        endColumn: 1
                                    },
                                    id: commandId
                                }
                            ],
                            dispose: () => { }
                        }
                    },
                    resolveCodeLens: function (model, codeLens, token) {
                        if (codeLens.id !== commandId) {
                            return codeLens
                        }
                        codeLens.command = {
                            id: codeLens.id,
                            title: 'Ask the FlowFuse Assistant ðŸª„',
                            tooltip: 'Click to ask FlowFuse Assistant for help writing JavaScript',
                            arguments: [model, codeLens, token]
                        }
                        return codeLens
                    }
                })

                let previousPrompt = null
                monaco.editor.registerCommand(commandId, function (accessor, model, codeLens, token) {
                    const node = RED.view.selection()?.nodes?.[0]
                    if (!node) {
                        console.warn('No node selected') // should not happen
                        return
                    }
                    if (!assistantOptions.enabled) {
                        RED.notify('The FlowFuse Assistant is not enabled', 'warning')
                        return
                    }
                    let xhr = null
                    const nodeId = node.id
                    const transactionId = `${nodeId}-${Date.now()}` // a unique id for this transaction
                    const thisEditor = getMonacoEditorForModel(model)
                    if (thisEditor) {
                        if (!document.body.contains(thisEditor.getDomNode())) {
                            console.warn('Editor is no longer in the DOM, cannot proceed.')
                            return
                        }
                        // walk up the tree to find the parent div with an id and include that in context
                        let parent = thisEditor.getDomNode().parentNode
                        while (parent?.tagName !== 'FORM') {
                            if (parent.id) {
                                break
                            }
                            parent = parent.parentNode
                        }
                        // const editorSection = parent?.id || '' // FUTURE: determine the code section users code lens was triggered in. Will be used to help the assistant understand the context of the code
                        const editorSection = 'on message' // hard coded for now since the code lens is only available in the "on message" editor in this first iteration

                        // FUTURE: for including selected text in the context for features like "fix my code", "refactor this", "what is this?" etc
                        // const userSelection = triggeredEditor.getSelection()
                        // const selectedText = model.getValueInRange(userSelection)

                        getUserInput({
                            defaultInput: previousPrompt,
                            title: 'FlowFuse JavaScript Assistant',
                            description: 'Enter a short prompt explaining what you want the function to do.'
                        }).then((prompt) => {
                            if (prompt) {
                                previousPrompt = prompt
                                const data = {
                                    prompt,
                                    promptHint: 'inline', // inline denotes that the prompt is for a code lens to generate specific node code for inside a function node
                                    transactionId,
                                    context: {
                                        modulesAllowed,
                                        codeSection: editorSection
                                        // selection: selectedText // FUTURE: include the selected text in the context for features like "fix my code", "refactor this", "what is this?" etc
                                    }
                                }
                                const busyNotification = showBusyNotification('Busy processing your request. Please wait...', function () {
                                    if (xhr) {
                                        xhr.abort('abort')
                                        xhr = null
                                    }
                                })
                                xhr = $.ajax({
                                    url: 'nr-assistant/function', // /function denotes this is a request for NODE JavaScript code
                                    type: 'POST',
                                    data,
                                    success: function (reply, textStatus, jqXHR) {
                                        const responseData = reply?.data?.data
                                        if (responseData?.func?.length > 0) {
                                            const currentSelection = thisEditor.getSelection()
                                            // ensure the editor is still present in the DOM
                                            if (!document.body.contains(thisEditor.getDomNode())) {
                                                console.warn('Editor is no longer in the DOM')
                                                return
                                            }
                                            busyNotification.close()
                                            thisEditor.focus()
                                            // insert the generated code at the current cursor position overwriting any selected text
                                            thisEditor.executeEdits('', [
                                                {
                                                    range: new monaco.Range(currentSelection.startLineNumber, currentSelection.startColumn, currentSelection.endLineNumber, currentSelection.endColumn),
                                                    text: responseData.func
                                                }
                                            ])
                                            // update the nodes output count the AI suggests a different number of outputs
                                            if (typeof responseData?.outputs === 'number' && responseData.outputs >= 0) {
                                                const outputsField = $('#node-input-outputs')
                                                const currentOutputs = parseInt(outputsField.val())
                                                if (!isNaN(currentOutputs) && typeof currentOutputs === 'number' && currentOutputs !== responseData.outputs) {
                                                    outputsField.val(responseData.outputs)
                                                    outputsField.trigger('change')
                                                }
                                            }

                                            // update libs - get the current list of libs then scan the response for any new ones
                                            // if the lib is not already in the list, add it
                                            if (modulesAllowed) {
                                                if (Array.isArray(responseData?.node_modules) && responseData.node_modules.length > 0) {
                                                    const _libs = []
                                                    const libs = $('#node-input-libs-container').editableList('items')
                                                    libs.each(function (i) {
                                                        const item = $(this)
                                                        const v = item.find('.node-input-libs-var').val()
                                                        let n = item.find('.node-input-libs-val').typedInput('type')
                                                        if (n === '_custom_') {
                                                            n = item.find('.node-input-libs-val').val()
                                                        }
                                                        if ((!v || (v === '')) ||
                                                            (!n || (n === ''))) {
                                                            return
                                                        }
                                                        _libs.push({
                                                            var: v,
                                                            module: n
                                                        })
                                                    })

                                                    responseData.node_modules.forEach((lib) => {
                                                        const existing = _libs.find(l => l.module === lib.module)
                                                        if (!existing) {
                                                            $('#node-input-libs-container').editableList('addItem', { var: lib.var, module: lib.module })
                                                        }
                                                    })
                                                }
                                            }
                                        } else {
                                            processAIErrorResponse(jqXHR, textStatus, 'No response from server')
                                        }
                                    },
                                    error: (jqXHR, textStatus, errorThrown) => {
                                        busyNotification.close()
                                        if (textStatus === 'abort' || errorThrown === 'abort' || jqXHR.statusText === 'abort') {
                                            // user cancelled
                                            return
                                        }
                                        processAIErrorResponse(jqXHR, textStatus, errorThrown)
                                    }
                                })
                            }
                        })
                    } else {
                        console.warn('Could not find editor for model', model.uri.toString())
                    }
                })
            }

            // setup actions for function builder
            const funcBuilderTitle = 'FlowFuse Function Node Assistant'
            RED.actions.add('ff:nr-assistant-function-builder', showFunctionBuilderPrompt, { label: funcBuilderTitle })

            // FUTURE: setup actions for flow builder
            // const flowBuilderTitle = 'FlowFuse Flow Assistant'
            // RED.actions.add('ff:nr-assistant-flow-builder', showFlowBuilderPrompt, { label: flowBuilderTitle })

            // Add toolbar button with menu items
            const toolbarMenuButton = $('<li><a id="red-ui-header-button-ff-ai" class="button fa fa-magic" href="#"></a></li>')
            toolbarMenuButton.prependTo('.red-ui-header-toolbar')
            RED.menu.init({
                id: 'red-ui-header-button-ff-ai',
                options: [
                    { id: 'menu-item-ff-ai-new-func', label: funcBuilderTitle, disabled: !assistantOptions.enabled, onselect: 'ff:nr-assistant-function-builder' }
                    // { id: "menu-item-ff-ai-new-flow", label: flowBuilderTitle, disabled: !assistantOptions.enabled, onselect: "ff:nr-assistant-flow-builder" } // FUTURE: enable this when the flow builder is ready
                ]
            })
            assistantInitialised = true
        }

        function getUserInput ({ title, description, placeholder, defaultInput } = {
            title: 'FlowFuse Assistant',
            description: 'Enter a short prompt explaining what you want the function node to do.',
            placeholder: 'Example: convert the payload to uppercase',
            defaultInput: ''
        }) {
            return new Promise((resolve, reject) => {
                const dialog = $('<div id="ff-nr-ai-dialog-input" class="hide red-ui-editor"></div>')
                const containerDiv = $('<div style="height: 100%;display: flex;flex-direction: column; height: calc(100% - 12px);">')
                if (description) {
                    containerDiv.append('<div style="margin-bottom: 12px; margin-top: -8px">' + description + '</div>')
                }
                const form = $('<form id="ff-nr-ai-dialog-input-fields" style="flex-grow: 1; margin-bottom: 6px;"></form>')
                const input = $('<textarea id="ff-nr-ai-dialog-input-editor" style="height:100%;width:100%; position:relative; resize: none;" maxlength="400" placeholder="' + (placeholder || '') + '">' + (defaultInput || '') + '</textarea>')
                form.append(input)
                containerDiv.append(form)
                dialog.append(containerDiv)
                const minHeight = 220 + (description ? 30 : 0)
                const minWidth = 520
                dialog.dialog({
                    autoOpen: true,
                    title: title || 'FlowFuse Assistant',
                    modal: true,
                    closeOnEscape: true,
                    height: minHeight,
                    width: 660,
                    minHeight,
                    minWidth,
                    resizable: true,
                    draggable: true,
                    open: function (event, ui) {
                        RED.keyboard.disable()
                        input.focus()
                        input.select()
                    },
                    close: function (event, ui) {
                        RED.keyboard.enable()
                    },
                    buttons: [
                        {
                            text: 'Ask the FlowFuse Assistant ðŸª„',
                            // class: 'primary',
                            click: function () {
                                const prompt = dialog.find('#ff-nr-ai-dialog-input-editor').val()
                                resolve(prompt)
                                $(this).dialog('close')
                            }
                        }
                    ],
                    cancel: function (event, ui) {
                        resolve(null)
                        $(this).dialog('close')
                    }
                })
            })
        }

        let previousFunctionBuilderPrompt
        function showFunctionBuilderPrompt (title, description) {
            if (!assistantOptions.enabled) {
                RED.notify('The FlowFuse Assistant is not enabled', 'warning')
                return
            }
            getUserInput({
                defaultInput: previousFunctionBuilderPrompt,
                title: title || 'FlowFuse Function Node Assistant',
                description: description || 'Enter a short prompt explaining what you want the function node to do.'
            }).then((prompt) => {
                /** @type {JQueryXHR} */
                let xhr = null
                if (prompt) {
                    previousFunctionBuilderPrompt = prompt
                    const url = 'nr-assistant/function'
                    const transactionId = generateId(8) + '-' + Date.now() // a unique id for this transaction
                    const body = {
                        prompt,
                        promptHint: 'node', // "node" denotes that the prompt is for a generating a function node (as importable JSON flow code)
                        transactionId
                    }
                    const busyNotification = showBusyNotification('Busy processing your request. Please wait...', function () {
                        if (xhr) {
                            xhr.abort('abort')
                            xhr = null
                        }
                    })
                    xhr = $.ajax({
                        url,
                        type: 'POST',
                        data: body,
                        timeout: assistantOptions.requestTimeout,
                        success: (reply, textStatus, jqXHR) => {
                            // console.log('showFunctionBuilderPrompt -> ajax -> success', reply)
                            busyNotification.close()
                            try {
                                const flowJson = typeof reply?.data?.flow === 'string' ? JSON.parse(reply.data.flow) : reply?.data?.flow
                                if (flowJson && Array.isArray(flowJson) && flowJson.length > 0) {
                                    importFlow(flowJson)
                                } else {
                                    processAIErrorResponse(jqXHR, textStatus, 'No response from server')
                                }
                            } catch (error) {
                                RED.notify('Sorry, something went wrong, please try again', 'error')
                            }
                        },
                        error: (jqXHR, textStatus, errorThrown) => {
                            // console.log('showFunctionBuilderPrompt -> ajax -> error', jqXHR, textStatus, errorThrown)
                            busyNotification.close()
                            if (textStatus === 'abort' || errorThrown === 'abort' || jqXHR.statusText === 'abort') {
                                // user cancelled
                                return
                            }
                            processAIErrorResponse(jqXHR, textStatus, errorThrown)
                        }
                    })
                }
            })
        }

        let previousFlowBuilderPrompt
        // eslint-disable-next-line no-unused-vars
        function showFlowBuilderPrompt (title, description) {
            if (!assistantOptions.enabled) {
                RED.notify('The FlowFuse Assistant is not enabled', 'warning')
                return
            }
            getUserInput({
                defaultInput: previousFlowBuilderPrompt,
                title: title || 'FlowFuse Flow Builder',
                description: description || 'Enter a short prompt explaining what you want the flow to do.'
            }).then((prompt) => {
                /** @type {JQueryXHR} */
                let xhr = null
                if (prompt) {
                    previousFlowBuilderPrompt = prompt
                    const url = 'nr-assistant/flow'
                    const transactionId = generateId(8) + '-' + Date.now() // a unique id for this transaction
                    const body = {
                        prompt,
                        transactionId
                    }
                    const busyNotification = showBusyNotification('Busy processing your request. Please wait...', function () {
                        if (xhr) {
                            xhr.abort('abort')
                            xhr = null
                        }
                    })
                    xhr = $.ajax({
                        url,
                        type: 'POST',
                        data: body,
                        timeout: assistantOptions.requestTimeout,
                        success: (reply, textStatus, jqXHR) => {
                            busyNotification.close()
                            try {
                                const flowJson = typeof reply?.data?.flow === 'string' ? JSON.parse(reply.data.flow) : reply?.data?.flow
                                if (flowJson && Array.isArray(flowJson) && flowJson.length > 0) {
                                    importFlow(flowJson)
                                } else {
                                    processAIErrorResponse(jqXHR, textStatus, 'No response from server')
                                }
                            } catch (error) {
                                RED.notify('Sorry, something went wrong, please try again', 'error')
                            }
                        },
                        error: (jqXHR, textStatus, errorThrown) => {
                            busyNotification.close()
                            if (textStatus === 'abort' || errorThrown === 'abort' || jqXHR.statusText === 'abort') {
                                // user cancelled
                                return
                            }
                            processAIErrorResponse(jqXHR, textStatus, errorThrown)
                        }
                    })
                }
            })
        }

        /**
         * Shows a busy notification with a cancel button
         * @param {string} [message] - The message to display in the notification
         * @param {function} [onCancel] - The function to call when the cancel button is clicked
         * @param {object} [context] - The context object to pass to the onCancel callback function
         * @returns {{close: () => {}}} - The notification object
         */
        function showBusyNotification (message, onCancel, context, poop) {
            message = message || 'Busy processing your request. Please wait...'
            const busyMessage = $('<div>')
            $('<span>').text(message).appendTo(busyMessage)
            $('<i>').addClass('fa fa-spinner fa-spin fa-fw').appendTo(busyMessage)
            // eslint-disable-next-line prefer-const
            let notification
            const buttons = [
                {
                    text: 'cancel',
                    click: function () {
                        if (onCancel) {
                            const result = onCancel(context)
                            if (result === false) {
                                return
                            }
                        }
                        notification.close()
                    }
                }
            ]
            notification = showNotification(busyMessage, { type: 'success', timeout: 0, fixed: true, modal: true, buttons })
            return notification
        }

        /**
         * Shows a busy notification with a cancel button
         * @param {string} message - The message to display in the notification
         * @param {object} [options] - The options to pass to the notification
         * @param {'error'|'warning'|'success'|'compact'} [options.type] - The type of notification to display
         * @param {Number} [options.timeout] - How long the notification should be shown for, in milliseconds. Default: 5000. This is ignored if the fixed property is set.
         * @param {boolean} [options.fixed] - Do not hide the notification after a timeout. This also prevents the click-to-close default behaviour of the notification.
         * @param {boolean} [options.modal] - Whether the notification should be modal
         * @param {array} [options.buttons] - An array of buttons to display in the notification. Each button should be an object with a text property and a click property. The click property should be a function to call when the button is clicked. The function will be passed the context object.
         * @returns {{close: () => {}}} - The notification object
         */
        function showNotification (message, options) {
            options = options || {}
            options.type = options.type || 'success'
            options.timeout = options.timeout || 5000
            options.fixed = options.fixed || false
            options.modal = options.modal || false
            const pendingNotification = RED.notify(message, options)
            return pendingNotification
        }

        function importFlow (flow, addFlow) {
            let newNodes = flow
            try {
                if (typeof flow === 'string') {
                    try {
                        flow = flow.trim()
                        if (flow.length === 0) {
                            return
                        }
                        newNodes = JSON.parse(flow)
                    } catch (err) {
                        const e = new Error(RED._('clipboard.invalidFlow', { message: err.message }))
                        e.code = 'NODE_RED'
                        throw e
                    }
                }
                const importOptions = { generateIds: true, addFlow }
                RED.notify('Place your generated flow onto the workspace', 'compact')
                RED.view.importNodes(newNodes, importOptions)
            } catch (error) {
                // console.log(error)
                RED.notify('Sorry, something went wrong, please try again', 'error')
            }
        }

        function processAIErrorResponse (jqXHR, textStatus, errorThrown) {
            console.warn('error', jqXHR, textStatus, errorThrown)
            RED.notify('Sorry, something went wrong, please try again', 'error')
        }

        function getMonacoEditorForModel (model) {
            // Get the URI of the model, scan the editors for the model with the same URI
            const modelUri = model.uri.toString()
            const editors = monaco.editor.getEditors()
            return editors.find(editor => editor && document.body.contains(editor.getDomNode()) && editor.getModel()?.uri?.toString() === modelUri)
        }

        function generateId (length = 16) {
            if (typeof length !== 'number' || length < 1) {
                throw new Error('Invalid length')
            }
            const iterations = Math.ceil(length / 2)
            const bytes = []
            for (let i = 0; i < iterations; i++) {
                bytes.push(Math.round(0xff * Math.random()).toString(16).padStart(2, '0'))
            }
            return bytes.join('').substring(0, length)
        }
        function debug () {
            if (RED.assistantPlugin?.DEBUG) {
                // eslint-disable-next-line no-console
                console.log('[nr-assistant]', ...arguments)
            }
        }
    }(RED, $))
</script>